-- Из домашнего задания 1

intToChar :: Int -> Char
intToChar n = toEnum (n + 48)
-- Также есть функции chr, ord в Data.Char

-- Решение домашнего задания 2

-- Нехвостовая рекурсия
fib 0 = 0
fib 1 = 1
fib n = fib (n - 1) + fib (n - 2)

-- Хвостовая рекурсия
-- Два последовательных числа Фибоначчи передаются как второй и третий аргументы
-- Первый аргумент является счетчиком
-- Трассировка:
-- fib 4 1 1 = fib 3 1 2 = fib 2 2 3 = fib 1 3 5 = fib 0 5 8 = 5
-- fib' counter f_{n-1} f_n
fib' :: Integer -> Integer -> Integer -> Integer
fib' 0 x _ = x
fib' n x y = fib' (n - 1) y (x + y)

fib'' n = fib' n 0 1

halve xs = splitAt (div (length xs) 2) xs

-- Сортировка слиянием

-- Сливает два упорядоченных списка
merge :: Ord a => [a] -> [a] -> [a]
merge [] ys = ys
merge xs [] = xs
merge l1@(x : xs) l2@(y : ys)
  | x < y = x : merge xs l2
  | otherwise = y : merge l1 ys

msort [] = []
msort [x] = [x]
msort xs =
  let (l1, l2) = halve xs in
    merge (msort l1) (msort l2)

-- Чтобы загрузить модуль Data.List, поместите в начале программы
-- import Data.List

-- В командной строке GHCi можно также сказать
-- :m + Data.List

-- Чтобы выгрузить модуль Data.List в командной строке GHCi
-- :m - Data.List

-- Имена загруженных модулей пишутся в подсказке GHCi

-- Если функция с одним и тем же именем имеется в двух загруженных модулях
-- (например, в программе и в библиотечном модуле), то GHCi выдает ошибку "Ambiguous occurrence".

-- Чтобы импортировать только функции nub и sort из модуля Data.List:
-- import Data.List (nub, sort)

-- Чтобы импортировать все функции, кроме nub и sort из модуля Data.List:
-- import Data.List hiding (nub, sort)
-- Так же можно поступить с модулем Prelude, который загружается по умолчанию.
-- Это позволяет дать этим функциям свои определения.

-- Чтобы поместить импортируемые функции в другое пространство имен:
-- import qualified Data.List
-- После этого функции будут доступны с префиксом Data.List, например, Data.List.sort

-- Чтобы поместить импортируемые функции в заданное пространство имен M:
-- import qualified Data.List as M
-- После этого функции будут доступны с префиксом M, например, M.sort

-- Создание своих модулей

-- Каждый модуль в своем файле
-- Имя модуля = имя файла
-- Расширение файла: .hs

-- Структура файла:

-- module Имя(определение1, определение2,..., определениеN) where
--  
-- import Модуль1(...)
-- import Модуль2(...)
--  
-- определение1
-- определение2
-- ...

-- После Имя идут экспортируемые определения.
-- Остальные определения в модуле могут использоваться только внутри данного модуля.
-- Если после Имя нет скобок, экспортируются все определения.

-- Модуль содержит определения
-- * типов
-- * значений (в том числе функций)
-- * классов типов
-- * экземпляров классов типов

-- Замечание о последовательнстях
-- Начало, разность и конец не обязаны быть константами

arithSeq start diff end = [start, start + diff .. end]

-- работает также с символами
-- ['A' .. 'Z']
-- и с Float и Double (разность по умолчанию равна 1)
-- В общем случае эта запись работает с типами, принадлежащими классу типов Enum

-- Замечание о сечениях
-- (-2) не функция, которая вычитает 2, а число -2
-- (subtract 2) -- функция, вычитающая 2

-- Передача функций как аргументов

-- композиция функций
-- (.)              :: (b -> c) -> (a -> b) -> (a -> c)
-- f . g            =  \ x -> f (g x)

-- Объявление бинарных операторов
-- Должны состоять из специальных символов: !#$%&⋆+./<=>?@\^|-~:
-- Двоеточие не должно быть первым символом
-- infix: неассоциативный оператор
-- infixl: левоассоциативный оператор
-- infixr: правоассоциативный оператор
-- Приоритет: от 0 до 9

infixl 6 #

-- Определение должно следовать сразу за объявлением
-- Левая часть равенства может быть в одном из двух стилей

--(#) x y = x + y
x # y = x + y

infixl 6 !

(!) f g x = f (g x)

-- Стандартные фукнции высших порядков (т.е. принимающие фукнции как аргументы)

-- flip             :: (a -> b -> c) -> b -> a -> c
-- flip f x y       =  f y x

-- curry            :: ((a, b) -> c) -> a -> b -> c
-- curry f x y      =  f (x, y)

-- uncurry          :: (a -> b -> c) -> ((a, b) -> c)
-- uncurry f p      =  f (fst p) (snd p)

-- ($) :: (a -> b) -> a -> b
-- ($) f x = f x

-- Применение функции имеет наивысший приоритет
-- Бинарный оператор $ правоассоциативный и имеет низший приоритет: 0
-- Поэтому вместо f x y (g z u) можно писать f x y $ g z u
-- Пример
-- sum (filter (> 10) (map (*2) [2..10]))
-- sum $ filter (> 10) $ map (*2) [2..10]
-- f $ g $ h $ x = f (g (h x))

-- map и filter есть в Prelude
-- map f [] = []
-- map f (x : xs) = (f x) : map f xs

-- filter :: (a -> Bool) -> [a] -> [a]
-- filter p []                 = []
-- filter p (x:xs) | p x       = x : filter p xs
--                 | otherwise = filter p xs

-- Альтернативно: filter p xs = [x | x <- xs, p x]

-- Пример
-- Пусть есть предикат prime :: Int -> Bool
-- head (filter prime [100000, 99999..]) -- наибольшее простое число, не превосходящее 100000

-- takeWhile               :: (a -> Bool) -> [a] -> [a]
-- takeWhile (/= ' ') "Первое слово в предложении"
-- возвращает "Первое"

-- Упражнения

isUpperAlpha :: Char -> Bool
isUpperAlpha x = elem x ['A'..'Z']

-- Альтернативно: isUpperAlpha = flip elem ['A'..'Z']
-- Это запись называется бесточечной (безаргументной)
-- isUpperAlpha x = flip elem ['A'..'Z'] x = elem x ['A'..'Z']

-- В общем случае вместо
-- f x = expression x
-- достаточно написать
-- f = expression

-- Что делают следующие два определения?
listOfFuns = map (*) [0..]
applyAll x = take 10 $ map ($ x) listOfFuns

-- Домашнее задание

-- Напишите модуль Homework3 в одноименном файле. Модуль должен
-- экспортировать только iter и composeAll. Внутри модуля
-- импортируйте Prelude за исключением остальных функций,
-- указанных ниже.

-- Напишите функцию nub, которая убирает вторые и последующие вхождения
-- каждого элемента из списка. Порядок первых вхождения при этом сохраняется.
-- Например, nub [1, 2, 3, 1, 1, 2] = [1, 2, 3] (есть в Data.List)

-- Напишите функцию powerset :: [a] -> [[a]], которая возвращает
-- список всех подсписков данного списка. Порядок элементов в возвращаемых
-- списках неважен.

-- Напишите foldr с помощью нехвостовой рекурсии (есть в Prelude)
-- foldr :: (a -> b -> b) -> b -> [a] -> b
-- foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)

-- Напишите foldl с помощью хвостовой рекурсии (есть в Prelude)
-- foldl :: (a -> b -> a) -> a -> [b] -> a
-- foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn

-- При написании функций ниже не используйте рекурсию.
-- По возможности используйте бесточечную (т.е. безаргументную) запись.

-- Выразите следующие функции через foldr: sum, length, (++)

-- Выразите reverse через foldl

-- Выразите iter через foldr и replicate
-- iter :: a -> (a -> a) -> Int -> a
-- iter x f n = f (f (... f x)...) (n раз, n >= 0)
-- replicate n x = [x, x, ..., x] (n элементов) (есть в Prelude)

-- Напишите функцию composeAll :: [a -> a] -> (a -> a), берущую
-- список функций и возвращающая их последовательную композицию
-- (функция, являющаяся головой списка, применяется последней).
-- Например, composeAll [(^2), (*2), (+3)] 0 = 36.

-- Дана функция
-- collatz 1 = [1]
-- collatz n
--   | even n = n : collatz (n `div` 2)
--   | otherwise = n : collatz (3 * n + 1)
-- Она возвращает последовательность Коллатца
-- (см. "Гипотеза Коллатца" в Википедии)

-- Напишите функцию longCollatz :: Int -> Int -> Int, такую что
-- longCollatz m n возвразает количество последовательностей Коллатца,
-- начинающихся с чисел от 1 до m и имеющих длину больше n.
-- Для этого можно сделать следущее.
-- 1. Найти список l от 1 до m.
-- 2. Найти список s последовательностей с началами в l.
-- 3. Оставить из s только списки длины > n.
-- 4. Найти длину оставшегося списка.

