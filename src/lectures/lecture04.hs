remove x [] = []
remove x (y : xs)
  | x == y = remove x xs
  | otherwise = y : remove x xs

nub [] = []
nub (x : l) = x : nub (remove x l)

powerset [] = [[]]
powerset (x : xs) =
  let p = powerset xs in
    p ++ map (x :) p

-- Напоминание определения конкатенации двух списков (++)
-- [] ++ l2 = l2
-- (h : t) ++ l2 = h : (t ++ l2)

append' l1 l2 = foldr (\h p -> h : p) l2 l1
-- Более коротко:
append'' l1 l2 = foldr (:) l2 l1

-- β-редукция: (\x -> M) N редуцируется (переписывается) к результату
-- подстановки N вместо x в M. Это подстановка фактического параметра
-- вместо формального в тело функции при ее вызове.

-- η-редукция: \x -> M x редуцируется к M, если x не входит в M.
-- Действительно, эти два терма ведут себя одинаково, когда выступают
-- в роли функции: (\x -> M x) N β-редуцируется к результату подстановки
-- N вместо x в M x, то есть в M N.

-- В функции append' выше:
-- \h p -> h : p есть обозначение для \h -> (\p -> ((:) h) p).
-- (\p -> ((:) h) p) η-редуцируется к (:) h. Далее, \h -> (:) h
-- η-редуцируется к (:).

-- Определение функции append'' эквивалентно
-- append'' = \l1 l2 -> foldr (:) l2 l1
-- Поэтому достаточно писать append'' = flip $ foldr (:).

map' f l = foldr (\h p -> f h : p) [] l
-- l можно опустить из левой и правой части

-- Выразите:
-- elem через foldr
-- filter через foldr

-- foldl1 и foldr1 работают на непустых списках и используют
-- крайние элементы списка как начальное значение. Из-за этого
-- результат функции имеет тот же тип, что и элементы списка.
-- Это не обязательно верно для foldl и foldr.

-- Реальные типы функций ниже более общие
-- foldr :: (a -> b -> b) -> b -> [a] -> b
-- foldl :: (b -> a -> b) -> b -> [a] -> b
-- foldr1 :: (a -> a -> a) -> [a] -> a
-- foldr1 :: (a -> a -> a) -> [a] -> a

maximum' l = foldl1 max l

-- Домашнее задание

-- Объясните следующую реализацию map:
map'' f = foldr ((:) . f) []

-- Изучите библиотечные функции, указанные вверху на с. 100 в книге:
-- Макеев Г.А. "Основы функционального программирования на языке Haskell".
-- См. ссылку на https://nngufall2016fp.wordpress.com/about-2/
-- Можно понять смысл функции из ее названия и типа или можно посмотреть
-- документацию по ней.

-- Напишите следующие функции, не используя рекурсии.
-- Можно использовать библиотечные функции.

-- Напишите функцию numPreds :: [a -> Bool] -> a -> Int, берущую
-- список предикатов и элемент, и находящую, сколько предикатов на
-- этом элементе возвращают True.

-- Напишите функцию findIndices :: (a -> Bool) -> [a] -> [Int],
-- находящую индексы тех элементов в списке, на которых условие
-- возвращает True.

-- Напишите функцию filterMapAnd :: [a -> Bool] -> [a] -> [a],
-- которая выбирает только те элементы из списка, на которых все
-- функции из списка функций возвращают True. Например,
-- filterMapAndMy [even, (>5), (<10)] [1..20] = [6,8] .
