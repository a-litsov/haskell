-- Домашнее задание 08.03.2019

-- 1. Прочитайте описание модуля Prelude, пропуская непонятные места.

-- Функция show :: Show a => a -> String возвращает текстовое представление
-- значения любого типа, принадлежащего классу Show (см. лекцию 2).
-- В частности, show 123 возвращает "123".

-- 2. Напишите функцию, строящую бесконечный строчку (список символов),
-- получающихся последовательной записью натуральных чисел:
-- "123456789101112131415..."
-- и проверьте ее, выведя первые сто символов, а также тысячный символ.
-- Используйте бесконечный список [1..] и функции map и show.

-- 3. Напишите функцию, строящую бесконечный список чисел, у которых
-- сумма десятичных цифр равна их произведению и вывести первые 10 его
-- элементов, а так же найти максимальный номер, который ваша реализация
-- и ваша система позволяет найти за разумное время.

-- 4. Напишите функцию, строящую бесконечный список подсписков чисел:
-- в первом подсписке будут степени единицы, во втором степени двойки,
-- в третьем -- тройки и так далее:
-- [[1,1,1,...], [2,4,8,...], [3,9,27,...], ...].

-- 5. Напомним, что конкатенация списка происходит рекурсией по первому
-- аргуметну и, следовательно, требует время и память, пропорциональные
-- длине первого списка. Поэтому, например, реализация concat :: [[a]] -> [a]
-- concat = foldl (++) [] имеет квадратичную сложность от общей длины
-- списков.

-- Для более эффективного реализации объединения списков в Prelude
-- имеется декларация type ShowS = String -> String.
-- Строчка s представляется функцией (s ++) :: ShowS, которая добавляет
-- s к своему аргументу. Если f1 :: ShowS представляет таким образом
-- s1 :: String, а f2 :: ShowS представляет s2 :: String, то вместо
-- s1 ++ s2 пишется f1 . f2. Чтобы получить явный вид f :: ShowS в виде
-- String, f применяется к "".
-- Пример: ("abc" ++) . ("def" ++) $ "" возвращает "abcdef"

-- Объясните, как это позволяет уменьшить сложность последовательного
-- объединения строк.

-- Функции showString и showChar ниже определены в Prelude, поэтому
-- их нужно исключить при импорте, как описано в лекции 3.

-- Напишите функции showString :: String -> ShowS и showChar :: Char -> ShowS,
-- которые конвертируют строчку и символ в представление ShowS.

-- На типах из класса Show есть также функция shows :: Show a => a -> ShowS.
-- Не используя рекурсию, напишите функцию
-- listToString :: Show a => [a] -> ShowS, которая за один проход по списку
-- возвращает конкатенацию представлений всех элементов списка. Например,
-- listToString [1,2,3,4] "" возвращает "1234".
